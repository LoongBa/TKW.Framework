# 领域模型验证与场景化映射技术设计文档 (V1.23)

本设计以 **“标注驱动生成 + 手写自治”** 为核心，xCodeGen 负责生成 80% 以上的场景化映射与基础验证代码，剩余复杂业务逻辑由开发者在 `.Logic.cs` 中手写扩展。

## 1. 核心设计原则 (Foundational Principles)

为了平衡性能、安全性与开发效率，本系统遵循以下三大基础策略：

- **策略一：持久化信任 (Persistence Trust)**：
  
  来自数据库（持久化层）的数据在 DTO 层面默认信任其已满足物理约束。在常规业务场景下，跳过重复的长度、格式等物理校验。
  
  - `IsFromPersistentSource == true` 时 DTO 跳过校验。

- **策略二：回填驱动验证 (Mapping-Driven Validation)**：
  
  只有当前场景下允许修改（`CanModify`）且需要回填的字段，才执行该字段的验证。**不修改 → 不回填 → 不验证**。

- **策略三：模型终验制 (Model Final Validation)**：
  
  Model 层的 `Create/Update` 动作一律显式调用 `Validate()`。即使 DTO 层面因只读跳过了某些字段，Model 依然负责所有数据（包括系统填充字段）的最终一致性守卫。

注意：以 DataAnnotations 为基础生成验证规则，后续根据需要兼容 FluentValidation。

---

## 2. 属性行为决策矩阵 (Property Decision Matrix)

行为由元数据（`Column`、`DtoField`）与场景（`EnumSceneFlags`）通过 `CodeGenPolicy` 决策引擎共同决定：

| **模式/特性组合**                 | **DTO 定义** | **ApplyToEntity (回填)** | **ValidateData (验证)** | **FromEntity (脱敏)**           | **典型例子**      |
| --------------------------- | ---------- | ---------------------- | --------------------- | ----------------------------- | ------------- |
| **`Ignore`**                | 否          | 否                      | 否                     | -                             | 内部敏感字段        |
| **`CanModify = false`**     | 是          | 否                      | 否                     | 正常                            | `UId`, `Code` |
| **`UpdateReadOnly = true`** | 是          | 仅 `Create` 场景可写        | 仅 `Create` 场景校验       | 正常                            | 证件号、初始类别      |
| **`Masking = true`**        | 是          | 取决于 `CanModify`        | 取决于 `CanModify`       | 根据 MaskPattern<br/>**执行掩码替换** | 手机号、邮箱        |

注：`DtoFieldAttribute` 仅定义字段与场景的关系、是否自动生成查询方法（目前仅支持`IsUnique`）。

## 3. 自动生成查询方法

### 3.1 自动生成规则与优先级

查询方法的生成遵循以下优先级，确保不生成重复功能的代码：

1. **主键查询 (Highest)**：基于 `ColumnAttribute.IsPrimary = true`，生成 `GetBy[Id]`。

2. **复合唯一索引查询**：基于 `IndexAttribute.IsUnique = true`，生成 `GetBy[Field1]And[Field2]`。

3. **组合条件查询 (New)**：基于 `DtoFieldAttribute.SearchGroup`。
   
   - 将所有具有相同 `SearchGroup` 名称的字段聚合，生成一个查询方法，如 `GetBy[SearchGroup](params)`。

4. **单一字段查询**：
   
   - 若 `SearchGroup` 为空且 `IsSearchable = true`，生成 `GetBy[FieldName]`。
   
   - 若 `IsUnique = true`，生成 `GetBy[FieldName]`。

### 3.2 SearchGroup 逻辑细则

- **命名规范**：生成的 Service/Repository 方法名默认为 `GetBy` + `SearchGroup`。

- **参数列表**：按字段在 `Model` 中定义的顺序（或 `Column.Position`）排列参数。

- **去重机制**：如果 `SearchGroup` 生成的方法与主键或唯一索引查询路径完全重合，则优先保留系统级索引方法。

> 验证规则由 `FreeSql` 的 `IndexAttribute`、`ColumnAttribute` 和 `DataAnnotations` 确定，如：
> 
> 1. 字段通过 `ColumnAttribute` 指定 `IsPrimary = true`，则生成单一键值的关联查询方法
>    
>    - 如：`MachantInfo GetMachantInfoById(long id)`
> 
> 2. 表通过 `IndexAttribute` 指定 `IsUnique = true`，则生成 `Fields` 指定的单键、多键的关联查询方法，如：
>    
>    - `Student GetStudentByClassAndName(string class, string name)` // 学生的班级、姓名
> 
> 3. 字段通过 `DataFieldAttribute` 指定 `IsUnique = true`，则生成单一键值的关联查询方法
>    
>    - 如：`MachantInfo GetMachantInfoByCode(string code)`
> 
> 4. 以 `ColumnAttribute.IsPrimary` 和 `IndexAttribute` 为主生成查询方法，`DataFieldAttribute` 作为补充。且某个查询方法如果已经生成过，不再重复生成。

---

## 4. 掩码系统规格 (Masking System Specification)

引入动态掩码逻辑，由 `MaskHelper` 静态类实现：

- **模式字符 (Pattern Characters)**：
  
  - `?`：匹配并保留真实值的**单个**字符。
  
  - `?*`：贪婪匹配并保留真实值的**连续多个**字符。
  
  - `#`：匹配真实值的**单个**字符并替换为遮蔽符 `*`。
  
  - `#*`：匹配真实值的**多个**字符并替换为遮蔽符 `*`。
  
  - **转义**：使用 `\` 处理原义字符，如 `\#`、`\*`。

- **示例**：
  
  - 手机号：`???####????` 或 `???#*????` $\rightarrow$ `139****5678`。
  
  - 邮件：`?#*@?#*.?#*` $\rightarrow$ `j***@g***.c*`。

- **掩码写回防护**：在 `ApplyToEntity` 时，若输入值等于该字段生成的掩码字符串（判定用户未编辑），**自动跳过回填**，防止掩码字符被写入数据库。

---

## 5. 核心决策引擎：`CodeGenPolicy`

该静态类已编译入 `xCodeGen.Core`，用于统一模板生成期与运行期的判定逻辑：

- **`IsAutoManaged(p)`**：识别系统自动管理字段（`Id`, `CreateTime`, `UpdateTime`, `IsDeleted`）及标记为 `IsIdentity` 或 `IsPrimary` 的属性。

- **`ShouldMapToEntity(p, scene)`**：判断当前场景是否需要执行属性赋值。

- **`ShouldValidateDto(p, scene, isFromPersistent)`**：判断 DTO 是否需要执行校验。

- **`ShouldValidateModel(p, scene, isFromPersistent)`**：判断 Model 是否需要执行校验。在 `ForceValidate` 场景下，该函数始终返回 `true`。

## 5. 自动化服务层逻辑 (Service Generation Specs)

**[New]** 服务层根据模型属性自动触发特定业务方法的生成：

### 5.1 状态管理逻辑 (Status Management)

系统通过识别布尔类型字段生成统一的状态切换接口，避免生成成对的冗余方法：

- **`IsEnabled` 识别**：生成 `InternalSetEnabledAsync(pk, bool enabled)`。

- **`IsDisabled` 识别**：生成 `InternalSetDisabledAsync(pk, bool disabled)`。

- **设计规范**：业务调用方通过 `bool` 参数控制目标状态，而非调用不同的方法名。

### 5.2 软删除与硬删除 (Soft/Hard Delete)

- **逻辑删除**：若存在 `IsDeleted` 字段，系统生成 `InternalSoftDeleteAsync`。

- **自动过滤**：`QueryForUser()` 会自动附加 `q.Where(x => !x.IsDeleted)` 过滤条件。

- **物理删除**：始终提供 `InternalHardDeleteAsync` 或 `InternalDeleteAsync` 作为底层指令。

### 5.3 业务钩子 (Partial Hooks)

生成的 Service 包含完整的生命周期钩子，允许开发者在不修改生成代码的情况下干预业务流程：

- **查询过滤**：`OnQueryFiltering` (基础查询)、`OnGraphQLFiltering` (接口查询)。

- **持久化前后**：`OnBeforeCreate/OnAfterCreate`, `OnBeforeUpdate/OnAfterUpdate`, `OnBeforeDelete/OnAfterDelete`。

---

## 6. 验证流与异常处理

### 6.1 验证分层逻辑

1. **自动物理验证 (`ValidateDataCore`)**：利用共享子模板 `_InternalValidation.cshtml` 生成。错误消息通过 `Summary` 或 `DisplayName` 增强可读性，将“字段名”与“错误信息”解耦。

2. **手写业务验证 (`OnCustomValidate / OnBusinessValidate`)**：手写局部方法，处理跨字段、跨表的复杂业务规则。

### 6.2 结构化异常机制

- **聚合错误**：验证方法返回 `IEnumerable<ValidationResult>`。

- **`ValidationResultsException`**：自定义异常类，接收完整的错误集合。由全局过滤器拦截并返回结构化的前端反馈。

---

## 7. 特殊场景处理 (ForceValidate)

- **强制验证 (ForceValidate)**：在 `Model.Validate()` 层面，若场景为`ForceValidate`，**忽略 `IsFromPersistentSource` 标记**，强制重走全量物理校验，确保数据在规则变更后的合规性。

- **提权回填**：在特定系统场景下，通过决策引擎允许对部分只读字段进行回填。

---

## 8. 标准业务流示例

1. **DTO 校验**：`dto.ValidateData(scene)`（基于 `ShouldValidateDto`）。

2. **载入实体**：从数据库 `Get` 原始实体对象。

3. **场景映射**：`dto.ApplyToEntity(entity, scene)`（根据 `ShouldMapToEntity` 自动跳过 `UpdateReadOnly` 字段）。

4. **模型终验**：`entity.Validate(scene)`。

5. **持久化**：执行 `SaveChangesAsync()`。

---
