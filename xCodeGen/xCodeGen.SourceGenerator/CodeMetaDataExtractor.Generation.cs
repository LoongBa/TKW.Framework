using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xCodeGen.Abstractions.Metadata;

namespace xCodeGen.SourceGenerator
{
    public partial class CodeMetaDataExtractor
    {
        /// <summary>
        /// 生成元数据代码文件
        /// </summary>
        public void GenerateMetaFile(SourceProductionContext context, ClassMetadata metadata)
        {
            try
            {
                // 清理类名中的非法字符（核心修复）
                string sanitizedClassName = SanitizeFileName(metadata.ClassName);
                LogDebug($"开始生成元数据文件: {sanitizedClassName}");

                // 生成安全的文件名
                var fileName = $"{MetaFilePrefix}{sanitizedClassName}Meta{GeneratedFileExtension}";
                var codeContent = BuildMetaCode(metadata);

                context.AddSource(fileName, SourceText.From(codeContent, Encoding.UTF8));
                LogDebug($"元数据文件生成完成: {fileName}");
            }
            catch (Exception ex)
            {
                LogDebug($"生成元数据文件失败: {ex.Message}");
                ReportError(context, $"生成元数据时出错: {ex.Message}");
            }
        }

        /// <summary>
        /// 构建结构化元数据代码内容
        /// </summary>
        private string BuildMetaCode(ClassMetadata metadata)
        {
            var codeBuilder = new StringBuilder();

            // 添加自动生成头部
            codeBuilder.AppendFormat(AutoGeneratedHeader, DateTime.UtcNow);

            // 引用必要的命名空间
            codeBuilder.AppendLine("using System;");
            codeBuilder.AppendLine("using System.Collections.Generic;");
            codeBuilder.AppendLine("using System.Collections.ObjectModel;");
            codeBuilder.AppendLine("using xCodeGen.Abstractions.Metadata;");
            codeBuilder.AppendLine();

            // 构建命名空间
            codeBuilder.AppendLine($"namespace {metadata.Namespace}.Generated;");
            codeBuilder.AppendLine();

            // 构建元数据类
            codeBuilder.AppendLine($"public class {metadata.ClassName}Meta");
            codeBuilder.AppendLine("{");
            codeBuilder.AppendLine("    /// <summary>");
            codeBuilder.AppendLine($"    /// {metadata.ClassName} 的结构化元数据");
            codeBuilder.AppendLine("    /// 可直接作为对象传递给模板引擎");
            codeBuilder.AppendLine("    /// </summary>");
            codeBuilder.AppendLine("    public static ClassMetadata Metadata { get; } = new ClassMetadata");
            codeBuilder.AppendLine("    {");

            // 填充类级元数据
            codeBuilder.AppendLine($"        Namespace = \"{EscapeString(metadata.Namespace)}\",");
            codeBuilder.AppendLine($"        ClassName = \"{EscapeString(metadata.ClassName)}\",");
            codeBuilder.AppendLine($"        FullName = \"{EscapeString(metadata.FullName)}\",");
            codeBuilder.AppendLine($"        Mode = \"{EscapeString(metadata.Mode)}\",");
            codeBuilder.AppendLine($"        SourceType = MetadataSource.{metadata.SourceType},");
            codeBuilder.AppendLine($"        TemplateName = \"{EscapeString(metadata.TemplateName)}\",");
            codeBuilder.AppendLine($"        BaseType = \"{EscapeString(metadata.BaseType)}\",");
            codeBuilder.AppendLine("        ImplementedInterfaces = new Collection<string>");
            codeBuilder.AppendLine("        {");
            foreach (var interFace in metadata.ImplementedInterfaces)
            {
                codeBuilder.AppendLine($"            \"{EscapeString(interFace)}\",");
            }
            codeBuilder.AppendLine("        },");

            // 填充方法集合
            codeBuilder.AppendLine("        Methods = new Collection<MethodMetadata>");
            codeBuilder.AppendLine("        {");
            foreach (var method in metadata.Methods)
            {
                codeBuilder.AppendLine("            new MethodMetadata");
                codeBuilder.AppendLine("            {");
                codeBuilder.AppendLine($"                Name = \"{EscapeString(method.Name)}\",");
                codeBuilder.AppendLine($"                ReturnType = \"{EscapeString(method.ReturnType)}\",");
                codeBuilder.AppendLine($"                IsAsync = {method.IsAsync.ToString().ToLower()},");
                codeBuilder.AppendLine($"                AccessModifier = \"{EscapeString(method.AccessModifier)}\",");

                // 填充参数集合
                codeBuilder.AppendLine("                Parameters = new List<ParameterMetadata>");
                codeBuilder.AppendLine("                {");
                foreach (var param in method.Parameters)
                {
                    codeBuilder.AppendLine("                    new ParameterMetadata");
                    codeBuilder.AppendLine("                    {");
                    codeBuilder.AppendLine($"                        Name = \"{EscapeString(param.Name)}\",");
                    codeBuilder.AppendLine($"                        TypeName = \"{EscapeString(param.TypeName)}\",");
                    codeBuilder.AppendLine($"                        TypeFullName = \"{EscapeString(param.TypeFullName)}\",");
                    codeBuilder.AppendLine($"                        IsNullable = {param.IsNullable.ToString().ToLower()},");
                    codeBuilder.AppendLine($"                        IsCollection = {param.IsCollection.ToString().ToLower()},");
                    codeBuilder.AppendLine($"                        CollectionItemType = {FormatStringValue(param.CollectionItemType)},");

                    // 填充参数特性
                    codeBuilder.AppendLine("                        Attributes = new List<AttributeMetadata>");
                    codeBuilder.AppendLine("                        {");
                    foreach (var attr in param.Attributes)
                    {
                        codeBuilder.AppendLine("                            new AttributeMetadata");
                        codeBuilder.AppendLine("                            {");
                        codeBuilder.AppendLine($"                                TypeFullName = {FormatStringValue(attr.TypeFullName)},");
                        codeBuilder.AppendLine("                                Properties = new Dictionary<string, object>");
                        codeBuilder.AppendLine("                                {");
                        foreach (var prop in attr.Properties)
                        {
                            codeBuilder.AppendLine($"                                    {{ \"{EscapeString(prop.Key)}\", {GetLiteralValue(prop.Value)} }} ,");
                        }
                        codeBuilder.AppendLine("                                }");
                        codeBuilder.AppendLine("                            },");
                    }
                    codeBuilder.AppendLine("                        }");
                    codeBuilder.AppendLine("                    },");
                }
                codeBuilder.AppendLine("                }");
                codeBuilder.AppendLine("            },");
            }
            codeBuilder.AppendLine("        }");
            codeBuilder.AppendLine("    };");
            codeBuilder.AppendLine("}");

            return codeBuilder.ToString();
        }

        /// <summary>
        /// 生成项目元数据上下文（接口+单例模式）
        /// </summary>
        public void GenerateProjectMetaContext(
            SourceProductionContext context,
            IEnumerable<ClassMetadata> allMetadatas,
            ProjectInfo projectInfo,
            MetadataChangeLog changeLog)
        {
            var classMetadatas = allMetadatas.ToList();
            try
            {
                var codeBuilder = new StringBuilder();
                codeBuilder.AppendLine("// <auto-generated/>");
                codeBuilder.AppendLine("#nullable disable");
                codeBuilder.AppendLine();
                codeBuilder.AppendLine("using System;");
                codeBuilder.AppendLine("using System.Collections.Generic;");
                codeBuilder.AppendLine("using System.Collections.ObjectModel;");
                codeBuilder.AppendLine("using System.Linq;");
                codeBuilder.AppendLine("using xCodeGen.Abstractions.Metadata;");
                codeBuilder.AppendLine();
                codeBuilder.AppendLine($"namespace {projectInfo.GeneratedNamespace};");
                codeBuilder.AppendLine();

                // 实现 IProjectMetaContext 接口
                codeBuilder.AppendLine("/// <summary>");
                codeBuilder.AppendLine("/// 自动生成的项目元数据上下文");
                codeBuilder.AppendLine("/// 实现 IProjectMetaContext 接口，通过单例模式全局访问");
                codeBuilder.AppendLine("/// </summary>");
                codeBuilder.AppendLine("public class ProjectMetaContext : IProjectMetaContext");
                codeBuilder.AppendLine("{");
                // 单例实例
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 全局唯一实例");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public static ProjectMetaContext Instance { get; } = new ProjectMetaContext();");
                codeBuilder.AppendLine();

                // 私有构造函数
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 私有构造函数，确保只能通过 Instance 访问");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    private ProjectMetaContext()");
                codeBuilder.AppendLine("    {");
                // 初始化自定义属性
                foreach (var prop in projectInfo.CreateProjectConfiguration().CustomProperties)
                {
                    codeBuilder.AppendLine($"        Configuration.CustomProperties[\"{EscapeString(prop.Key)}\"] = \"{EscapeString(prop.Value)}\";");
                }
                codeBuilder.AppendLine();
                // 初始化变更日志
                foreach (var added in changeLog.Added)
                {
                    codeBuilder.AppendLine($"        ChangeLog.Added.Add({added.Namespace}.Generated.{added.ClassName}Meta.Metadata);");
                }
                foreach (var modified in changeLog.Modified)
                {
                    codeBuilder.AppendLine($"        ChangeLog.Modified.Add({modified.Namespace}.Generated.{modified.ClassName}Meta.Metadata);");
                }
                foreach (var removed in changeLog.RemovedClassNames)
                {
                    codeBuilder.AppendLine($"        ChangeLog.RemovedClassNames.Add(\"{EscapeString(removed)}\");");
                }
                codeBuilder.AppendLine("    }");
                codeBuilder.AppendLine();

                // 元数据版本
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 元数据 schema 版本");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public string MetadataSchemaVersion => \"2.0\";");
                codeBuilder.AppendLine();

                // 类元数据集合
                codeBuilder.AppendLine("    private readonly List<ClassMetadata> _allMetadatas = new List<ClassMetadata>");
                codeBuilder.AppendLine("    {");
                foreach (var metadata in classMetadatas.OrderBy(m => m.ClassName))
                {
                    codeBuilder.AppendLine($"        {metadata.Namespace}.Generated.{metadata.ClassName}Meta.Metadata,");
                }
                codeBuilder.AppendLine("    };");
                codeBuilder.AppendLine();
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 所有类元数据的只读集合");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public IReadOnlyList<ClassMetadata> AllMetadatas => _allMetadatas.AsReadOnly();");
                codeBuilder.AppendLine();

                // 项目配置
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 项目配置信息");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public ProjectConfiguration Configuration { get; } = new ProjectConfiguration(");
                codeBuilder.AppendLine($"        projectDirectory: \"{EscapeString(projectInfo.ProjectDirectory)}\",");
                codeBuilder.AppendLine($"        outputPath: \"{EscapeString(projectInfo.OutputPath)}\",");
                codeBuilder.AppendLine($"        rootNamespace: \"{EscapeString(projectInfo.RootNamespace)}\",");
                codeBuilder.AppendLine($"        assemblyName: \"{EscapeString(projectInfo.AssemblyName)}\",");
                codeBuilder.AppendLine($"        targetFramework: \"{EscapeString(projectInfo.TargetFramework)}\",");
                codeBuilder.AppendLine($"        buildConfiguration: \"{EscapeString(projectInfo.BuildConfiguration)}\",");
                codeBuilder.AppendLine($"        langVersion: \"{EscapeString(projectInfo.LangVersion)}\",");
                codeBuilder.AppendLine($"        nullable: \"{EscapeString(projectInfo.Nullable)}\",");
                codeBuilder.AppendLine($"        generatedNamespace: \"{EscapeString($"{projectInfo.GeneratedNamespace}")}\",");
                codeBuilder.AppendLine($"        generatedFilesDirectory: \"{EscapeString(projectInfo.GeneratedFilesDirectory)}\",");
                codeBuilder.AppendLine($"        generatorVersion: \"{EscapeString(projectInfo.GeneratorVersion)}\"");
                codeBuilder.AppendLine("    );");
                codeBuilder.AppendLine();

                // 变更日志
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 元数据变更日志");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public MetadataChangeLog ChangeLog { get; } = new MetadataChangeLog");
                codeBuilder.AppendLine("    {");
                codeBuilder.AppendLine($"        GenerationTimestamp = new DateTime({changeLog.GenerationTimestamp.Ticks}, DateTimeKind.Utc)");
                codeBuilder.AppendLine("    };");
                codeBuilder.AppendLine();

                // 查找方法
                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 按类名查找元数据");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public ClassMetadata FindByClassName(string className)");
                codeBuilder.AppendLine("    {");
                codeBuilder.AppendLine("        if (className == null) return null;");
                codeBuilder.AppendLine("        foreach (var metadata in _allMetadatas)");
                codeBuilder.AppendLine("        {");
                codeBuilder.AppendLine("            if (string.Equals(metadata.ClassName, className, StringComparison.Ordinal))");
                codeBuilder.AppendLine("            {");
                codeBuilder.AppendLine("                return metadata;");
                codeBuilder.AppendLine("            }");
                codeBuilder.AppendLine("        }");
                codeBuilder.AppendLine("        return null;");
                codeBuilder.AppendLine("    }");
                codeBuilder.AppendLine();

                codeBuilder.AppendLine("    /// <summary>");
                codeBuilder.AppendLine("    /// 按命名空间查找元数据");
                codeBuilder.AppendLine("    /// </summary>");
                codeBuilder.AppendLine("    public IEnumerable<ClassMetadata> FindByNamespace(string @namespace)");
                codeBuilder.AppendLine("    {");
                codeBuilder.AppendLine("        if (@namespace == null) yield break;");
                codeBuilder.AppendLine("        foreach (var metadata in _allMetadatas)");
                codeBuilder.AppendLine("        {");
                codeBuilder.AppendLine("            if (string.Equals(metadata.Namespace, @namespace, StringComparison.Ordinal))");
                codeBuilder.AppendLine("            {");
                codeBuilder.AppendLine("                yield return metadata;");
                codeBuilder.AppendLine("            }");
                codeBuilder.AppendLine("        }");
                codeBuilder.AppendLine("    }");
                codeBuilder.AppendLine("}");

                context.AddSource("ProjectMetaContext.g.cs",
                    SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
            }
            catch (Exception ex)
            {
                ReportError(context, $"生成 ProjectMetaContext 失败: {ex.Message}");
            }
        }

        /// <summary>
        /// 生成调试日志文件
        /// </summary>
        private void GenerateDebugLogFile(SourceProductionContext context)
        {
            var logContent = new StringBuilder();
            logContent.AppendLine("// <auto-generated/>");
            logContent.AppendLine($"namespace {DebugLogNamespace};");
            logContent.AppendLine();
            logContent.AppendLine($"public interface {DebugLogInterfaceName}");
            logContent.AppendLine("{");
            logContent.AppendLine("    IEnumerable<string> GetLogs();");
            logContent.AppendLine("}");
            logContent.AppendLine();
            logContent.AppendLine($"public class CodeMetaDataExtractorLog : {DebugLogInterfaceName}");
            logContent.AppendLine("{");
            logContent.AppendLine("    private readonly List<string> _logs = new List<string>");
            logContent.AppendLine("    {");
            foreach (var log in _debugLogs)
            {
                logContent.AppendLine($"        \"{EscapeString(log)}\",");
            }
            logContent.AppendLine("    };");
            logContent.AppendLine();
            logContent.AppendLine("    public IEnumerable<string> GetLogs() => _logs;");
            logContent.AppendLine("}");

            context.AddSource("Logs/CodeMetaData_DebugLog.g.cs",
                SourceText.From(logContent.ToString(), Encoding.UTF8));
        }

        /// <summary>
        /// 报告生成错误
        /// </summary>
        private void ReportError(SourceProductionContext context, string message)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "CMD001", "元数据生成错误", message, "CodeMeta",
                    DiagnosticSeverity.Error, true),
                Location.None));
        }

        /// <summary>
        /// 带上下文的日志记录（支持诊断输出）
        /// </summary>
        private void LogDebug(SourceProductionContext context, string message)
        {
            LogDebug(message);
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "CMD000", "元数据生成调试", message, "CodeMeta",
                    DiagnosticSeverity.Info, true),
                Location.None));
        }

        /// <summary>
        /// 转义字符串中的特殊字符
        /// </summary>
        private string EscapeString(string value)
        {
            return value?.Replace("\\", "\\\\").Replace("\"", "\\\"") ?? string.Empty;
        }

        /// <summary>
        /// 格式化字符串值（处理null情况）
        /// </summary>
        private string FormatStringValue(string value)
        {
            return value == null ? "null" : $"\"{EscapeString(value)}\"";
        }

        /// <summary>
        /// 将对象值转换为C#字面量
        /// </summary>
        private string GetLiteralValue(object value)
        {
            if (value == null) return "null";
            if (value is string s) return $"\"{EscapeString(s)}\"";
            if (value is bool b) return b.ToString().ToLower();
            if (value is Enum e) return $"{e.GetType().Name}.{e}";
            return value.ToString();
        }

        /// <summary>
        /// 清理文件名中的非法字符（防止路径格式错误）
        /// </summary>
        private string SanitizeFileName(string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
                return "Unknown";

            // 获取系统不允许的文件名字符
            char[] invalidChars = System.IO.Path.GetInvalidFileNameChars();

            // 替换非法字符为下划线
            return new string(fileName.Select(c => invalidChars.Contains(c) ? '_' : c).ToArray());
        }
    }
}