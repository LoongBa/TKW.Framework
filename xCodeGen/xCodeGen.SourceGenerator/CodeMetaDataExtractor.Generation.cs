using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xCodeGen.Abstractions.Metadata;

namespace xCodeGen.SourceGenerator
{
    public partial class CodeMetaDataExtractor
    {
        public void GenerateMetaFile(SourceProductionContext context, ClassMetadata metadata)
        {
            try
            {
                string sanitizedClassName = SanitizeFileName(metadata.ClassName);
                var fileName = $"{MetaFilePrefix}{sanitizedClassName}Meta{GeneratedFileExtension}";
                var codeContent = BuildMetaCode(metadata);
                context.AddSource(fileName, SourceText.From(codeContent, Encoding.UTF8));
            }
            catch (Exception ex) { ReportError(context, $"生成元数据时出错: {ex.Message}"); }
        }

        private string BuildMetaCode(ClassMetadata metadata)
        {
            var codeBuilder = new StringBuilder();
            codeBuilder.AppendFormat(AutoGeneratedHeader, DateTime.UtcNow);

            codeBuilder.AppendLine("using System;");
            codeBuilder.AppendLine("using System.Collections.Generic;");
            codeBuilder.AppendLine("using System.Collections.ObjectModel;");
            codeBuilder.AppendLine("using xCodeGen.Abstractions.Metadata;");
            codeBuilder.AppendLine();
            codeBuilder.AppendLine($"namespace {metadata.Namespace}.Generated");
            codeBuilder.AppendLine("{");
            codeBuilder.AppendLine($"    public class {metadata.ClassName}Meta");
            codeBuilder.AppendLine("    {");

            // 记录类 Summary 来源
            if (metadata.GenerateCodeSettings.TryGetValue("ClassSummarySource", out var source))
                codeBuilder.AppendLine($"        // [Summary Source: {source}]");

            codeBuilder.AppendLine("        public static ClassMetadata Metadata { get; } = new ClassMetadata");
            codeBuilder.AppendLine("        {");
            codeBuilder.AppendLine($"            Namespace = \"{EscapeString(metadata.Namespace)}\",");
            codeBuilder.AppendLine($"            ClassName = \"{EscapeString(metadata.ClassName)}\",");
            codeBuilder.AppendLine($"            FullName = \"{EscapeString(metadata.FullName)}\",");
            codeBuilder.AppendLine($"            Mode = \"{EscapeString(metadata.Mode)}\",");
            codeBuilder.AppendLine($"            SourceType = MetadataSource.{metadata.SourceType},");
            codeBuilder.AppendLine($"            Summary = {FormatStringValue(metadata.Summary)},");
            codeBuilder.AppendLine($"            IsRecord = {metadata.IsRecord.ToString().ToLower()},");
            codeBuilder.AppendLine($"            TypeKind = \"{metadata.TypeKind}\",");
            codeBuilder.AppendLine($"            TemplateName = \"{EscapeString(metadata.TemplateName)}\",");
            codeBuilder.AppendLine($"            BaseType = \"{EscapeString(metadata.BaseType)}\",");

            // --- 序列化 Class 级别的 Attributes ---
            codeBuilder.AppendLine("            Attributes = new Collection<AttributeMetadata>");
            codeBuilder.AppendLine("            {");
            foreach (var attr in metadata.Attributes)
            {
                BuildAttributeInitialization(codeBuilder, attr, "                ");
            }
            codeBuilder.AppendLine("            },");

            codeBuilder.AppendLine("            Properties = new Collection<PropertyMetadata>");
            codeBuilder.AppendLine("            {");
            foreach (var prop in metadata.Properties)
            {
                codeBuilder.AppendLine("                new PropertyMetadata");
                codeBuilder.AppendLine("                {");
                codeBuilder.AppendLine($"                    Name = \"{EscapeString(prop.Name)}\",");
                codeBuilder.AppendLine($"                    TypeName = \"{EscapeString(prop.TypeName)}\",");
                codeBuilder.AppendLine($"                    TypeFullName = \"{EscapeString(prop.TypeFullName)}\",");
                codeBuilder.AppendLine($"                    IsNullable = {prop.IsNullable.ToString().ToLower()},");
                codeBuilder.AppendLine($"                    Summary = {FormatStringValue(prop.Summary)},");
                codeBuilder.AppendLine("                    Attributes = new List<AttributeMetadata>");
                codeBuilder.AppendLine("                    {");
                foreach (var attr in prop.Attributes)
                {
                    BuildAttributeInitialization(codeBuilder, attr, "                        ");
                }
                codeBuilder.AppendLine("                    }");
                codeBuilder.AppendLine("                },");
            }
            codeBuilder.AppendLine("            },");

            codeBuilder.AppendLine("            Methods = new Collection<MethodMetadata>");
            codeBuilder.AppendLine("            {");
            foreach (var method in metadata.Methods)
            {
                codeBuilder.AppendLine("                new MethodMetadata");
                codeBuilder.AppendLine("                {");
                codeBuilder.AppendLine($"                    Name = \"{EscapeString(method.Name)}\",");
                codeBuilder.AppendLine($"                    ReturnType = \"{EscapeString(method.ReturnType)}\",");
                codeBuilder.AppendLine($"                    IsAsync = {method.IsAsync.ToString().ToLower()},");
                codeBuilder.AppendLine($"                    Summary = {FormatStringValue(method.Summary)},");
                codeBuilder.AppendLine($"                    AccessModifier = \"{EscapeString(method.AccessModifier)}\",");
                codeBuilder.AppendLine("                    Parameters = new List<ParameterMetadata>");
                codeBuilder.AppendLine("                    {");
                foreach (var param in method.Parameters)
                {
                    codeBuilder.AppendLine($"                        new ParameterMetadata {{ Name = \"{EscapeString(param.Name)}\", TypeName = \"{EscapeString(param.TypeName)}\", IsNullable = {param.IsNullable.ToString().ToLower()}, Summary = {FormatStringValue(param.Summary)} }},");
                }
                codeBuilder.AppendLine("                    }");
                codeBuilder.AppendLine("                },");
            }
            codeBuilder.AppendLine("            }");
            codeBuilder.AppendLine("        };");
            codeBuilder.AppendLine("    }");
            codeBuilder.AppendLine("}");

            return codeBuilder.ToString();
        }

        /// <summary>
        /// 内部辅助：构建 AttributeMetadata 的 C# 初始化代码
        /// </summary>
        private void BuildAttributeInitialization(StringBuilder codeBuilder, AttributeMetadata attr, string indent)
        {
            codeBuilder.AppendLine($"{indent}new AttributeMetadata");
            codeBuilder.AppendLine($"{indent}{{");
            codeBuilder.AppendLine($"{indent}    Name = \"{EscapeString(attr.Name)}\",");
            codeBuilder.AppendLine($"{indent}    TypeFullName = \"{EscapeString(attr.TypeFullName)}\",");

            // 序列化构造函数参数
            codeBuilder.AppendLine($"{indent}    ConstructorArguments = new Collection<object>");
            codeBuilder.AppendLine($"{indent}    {{");
            foreach (var arg in attr.ConstructorArguments)
            {
                codeBuilder.AppendLine($"{indent}        {GetLiteralValue(arg)},");
            }
            codeBuilder.AppendLine($"{indent}    }},");

            // 序列化命名参数字典 (Properties & NamedArguments)
            codeBuilder.AppendLine($"{indent}    Properties = new Dictionary<string, object>");
            codeBuilder.AppendLine($"{indent}    {{");
            foreach (var prop in attr.Properties)
            {
                codeBuilder.AppendLine($"{indent}        {{ \"{EscapeString(prop.Key)}\", {GetLiteralValue(prop.Value)} }},");
            }
            codeBuilder.AppendLine($"{indent}    }},");

            codeBuilder.AppendLine($"{indent}    NamedArguments = new Dictionary<string, object>");
            codeBuilder.AppendLine($"{indent}    {{");
            foreach (var prop in attr.Properties)
            {
                codeBuilder.AppendLine($"{indent}        {{ \"{EscapeString(prop.Key)}\", {GetLiteralValue(prop.Value)} }},");
            }
            codeBuilder.AppendLine($"{indent}    }}");

            codeBuilder.AppendLine($"{indent}}},");
        }

        public void GenerateProjectMetaContext(SourceProductionContext context, IEnumerable<ClassMetadata> allMetadatas, ProjectInfo projectInfo, MetadataChangeLog changeLog)
        {
            var classMetadatas = allMetadatas.ToList();
            try
            {
                var codeBuilder = new StringBuilder();
                codeBuilder.AppendLine("// <auto-generated/>\r\n#nullable disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing xCodeGen.Abstractions.Metadata;\r\n\r\nnamespace " + projectInfo.GeneratedNamespace + "\r\n{");
                codeBuilder.AppendLine("    public class ProjectMetaContext : IProjectMetaContext\r\n    {");
                codeBuilder.AppendLine("        public static ProjectMetaContext Instance { get; } = new ProjectMetaContext();\r\n        private readonly List<ClassMetadata> _allMetadatas = new List<ClassMetadata>();\r\n        private ProjectMetaContext()\r\n        {");
                foreach (var metadata in classMetadatas.OrderBy(m => m.ClassName))
                    codeBuilder.AppendLine($"            _allMetadatas.Add({metadata.Namespace}.Generated.{metadata.ClassName}Meta.Metadata);");
                codeBuilder.AppendLine("        }\r\n        public IReadOnlyList<ClassMetadata> AllMetadatas => _allMetadatas.AsReadOnly();");
                codeBuilder.AppendLine("        public ProjectConfiguration Configuration { get; } = new ProjectConfiguration(projectDirectory: \"" + EscapeString(projectInfo.ProjectDirectory) + "\", outputPath: \"" + EscapeString(projectInfo.OutputPath) + "\", rootNamespace: \"" + EscapeString(projectInfo.RootNamespace) + "\", assemblyName: \"" + EscapeString(projectInfo.AssemblyName) + "\", targetFramework: \"" + EscapeString(projectInfo.TargetFramework) + "\", buildConfiguration: \"" + EscapeString(projectInfo.BuildConfiguration) + "\", langVersion: \"" + EscapeString(projectInfo.LangVersion) + "\", nullable: \"" + EscapeString(projectInfo.Nullable) + "\", generatedNamespace: \"" + EscapeString(projectInfo.GeneratedNamespace) + "\", generatedFilesDirectory: \"" + EscapeString(projectInfo.GeneratedFilesDirectory) + "\", generatorVersion: \"" + EscapeString(projectInfo.GeneratorVersion) + "\");");
                codeBuilder.AppendLine("        public MetadataChangeLog ChangeLog { get; } = new MetadataChangeLog();\r\n        public string MetadataSchemaVersion => \"2.0\";\r\n        public ClassMetadata FindByClassName(string className) => _allMetadatas.FirstOrDefault(m => m.ClassName == className);\r\n        public IEnumerable<ClassMetadata> FindByNamespace(string @namespace) => _allMetadatas.Where(m => m.Namespace == @namespace);\r\n    }\r\n}");
                context.AddSource("ProjectMetaContext.g.cs", SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
            }
            catch (Exception ex) { ReportError(context, $"生成 ProjectMetaContext 失败: {ex.Message}"); }
        }

        private void GenerateDebugLogFile(SourceProductionContext context) { var logContent = new StringBuilder(); logContent.AppendLine("namespace " + DebugLogNamespace + " { public class CodeMetaData_DebugLog { public static List<string> Logs = new List<string>(); } }"); context.AddSource("Logs/CodeMetaData_DebugLog.g.cs", SourceText.From(logContent.ToString(), Encoding.UTF8)); }
        private void ReportError(SourceProductionContext context, string message) { context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("CMD001", "元数据生成错误", message, "CodeMeta", DiagnosticSeverity.Error, true), Location.None)); }
        private string EscapeString(string value) { if (value == null) return string.Empty; return value.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "").Replace("\n", "\\n"); }
        private string FormatStringValue(string value) { if (string.IsNullOrEmpty(value)) return "\"\""; return "@\"" + value.Replace("\"", "\"\"") + "\""; }

        /// <summary>
        /// 获取值的字面量表示，确保类型安全
        /// </summary>
        private string GetLiteralValue(object value)
        {
            if (value == null) return "null";
            if (value is string s) return $"\"{EscapeString(s)}\"";
            if (value is bool b) return b.ToString().ToLower();
            if (value is int i) return i.ToString();
            if (value is long l) return l.ToString() + "L";
            if (value is Enum e) return $"{e.GetType().Name}.{e}";

            // 处理 typeof() 情况
            var strVal = value.ToString();
            if (strVal.Contains("typeof(")) return strVal;

            return $"\"{EscapeString(strVal)}\""; // 默认作为字符串回退，防止生成非法代码
        }

        private string SanitizeFileName(string fileName) => string.IsNullOrEmpty(fileName) ? "Unknown" : new string(fileName.Select(c => System.IO.Path.GetInvalidFileNameChars().Contains(c) ? '_' : c).ToArray());
    }
}