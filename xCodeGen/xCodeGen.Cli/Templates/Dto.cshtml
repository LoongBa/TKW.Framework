@using System.Linq
@using xCodeGen.Abstractions.Metadata
@model xCodeGen.Abstractions.Metadata.ClassMetadata
@{
    var dtoClassName = Model.ClassName + "Dto";
    var ns = Model.Namespace;
    var dtoProps = Model.Properties
        .Where(p => !p.Attributes.Any(a => a.TypeFullName.Contains("DtoIgnore")))
        .OrderBy(p => {
            var col = p.Attributes.FirstOrDefault(a => a.TypeFullName.Contains("ColumnAttribute"));
            return col?.Properties.ContainsKey("Position") == true ? (int)col.Properties["Position"] : 999;
        }).ToList();

    string metaHash = Model.GenerateCodeSettings?.ContainsKey("MetadataHash") == true 
        ? Model.GenerateCodeSettings["MetadataHash"]?.ToString() : "N/A";
    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
}
// <auto-generated>
// 此文件由 xCodeGen 自动生成，请勿手动修改。
// @@[xCodeGen.Hash: @metaHash]
// 模型: @Model.ClassName (@Model.FullName)
// 生成时间: @timestamp
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using TKW.Framework.Domain.Interfaces;
using TKW.Framework.Common.Enumerations;
using TKW.Framework.Domain.Interception.Filters;
using @ns;

namespace @(ns).DTOs;

/// <summary>
/// @(string.IsNullOrWhiteSpace(Model.Summary) ? Model.ClassName + " DTO" : Raw(Model.Summary))
/// </summary>
public partial record @dtoClassName : IDomainDto<@Model.ClassName>, IValidatableObject
{
    #region 属性定义
@foreach (var p in dtoProps)
{
    @:    /// <summary> @(string.IsNullOrWhiteSpace(p.Summary) ? p.Name : Raw(p.Summary)) </summary>
    @:    public @(p.TypeName) @(p.Name) { get; init; }
}
    #endregion

    #region 转换逻辑

    public static @dtoClassName FromEntity(@Model.ClassName entity)
    {
        ArgumentNullException.ThrowIfNull(entity);
        return new @dtoClassName 
        {
            @foreach (var p in dtoProps) {
            @: @(p.Name) = entity.@(p.Name),
            }
            _isFromPersistentSource = true // 标记持久化来源 
        };
    }

    public @Model.ClassName ApplyToEntity(@Model.ClassName entity, EnumSceneFlags scene = EnumSceneFlags.Update)
    {
        ArgumentNullException.ThrowIfNull(entity);
        @foreach (var p in dtoProps) {
            if (new[]{"Id","CreateTime","UpdateTime"}.Contains(p.Name)) continue;
            @:entity.@(p.Name) = this.@(p.Name);
        }

        OnApplyCustomMapping(entity, scene);

        return entity;
    }

    #endregion

    #region 验证逻辑

    /// <summary>
    /// 适配 IValidatableObject 接口，默认按 Create 场景验证 [cite: 26]
    /// </summary>
    public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        return ValidateDataCore(EnumSceneFlags.Create);
    }

    /// <summary>
    /// 执行统一验证 (包含自动生成的数据验证和自定义业务数据验证) [cite: 27-31]
    /// </summary>
    public void ValidateData(EnumSceneFlags scene = EnumSceneFlags.All)
    {
        if (IsFromPersistentSource) return;

        // 1. 执行自动生成的数据验证
        var results = ValidateDataCore(scene).ToList();
        
        // 2. 收集手写扩展验证结果
        OnCustomValidate(scene, results);

        // 3. 统一抛出异常 (建议使用自定义聚合异常)
        if (results.Any())
            throw new ValidationException(results.First().ErrorMessage); 
    }

    /// <summary>自动生成的领域一致性验证</summary>
    protected IEnumerable<ValidationResult> ValidateDataCore(EnumSceneFlags scene = EnumSceneFlags.None)
    {
        @{ await IncludeAsync("_InternalValidation.cshtml", Model); }
        yield break;
    }

    #endregion

    private bool _isFromPersistentSource = false;
    public bool IsFromPersistentSource => _isFromPersistentSource;

    partial void OnApplyCustomMapping(@Model.ClassName entity, EnumSceneFlags scene);
    partial void OnCustomValidate(EnumSceneFlags scene, List<ValidationResult> results);
}