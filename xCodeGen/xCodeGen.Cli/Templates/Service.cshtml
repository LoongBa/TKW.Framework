@using System.Linq
@using xCodeGen.Abstractions.Metadata
@model xCodeGen.Abstractions.Metadata.ClassMetadata
@{
    var className = Model.ClassName;
    var serviceName = $"{className}Service";
    var namespaceName = Model.Namespace.Replace(".Models", ".Services");
    var summary = Model.Summary ?? "领域服务基础实现";
    
    // 属性探测
    var hasIsDeleted = Model.Properties.Any(p => p.Name == "IsDeleted");
    var hasIsEnabled = Model.Properties.Any(p => p.Name == "IsEnabled");
    var hasIsDisabled = Model.Properties.Any(p => p.Name == "IsDisabled");
    var hasUId = Model.Properties.Any(p => p.Name == "UId");

    // 主键定位：优先找 Primary 标记，其次按约定找 Id
    var pkProp = Model.Properties.FirstOrDefault(p => 
        p.Attributes.Any(a => a.TypeFullName.Contains("ColumnAttribute") && 
        a.Properties.ContainsKey("IsPrimary") && (bool)a.Properties["IsPrimary"])) 
        ?? Model.Properties.FirstOrDefault(p => p.Name == "Id");

    var pkType = pkProp?.TypeName ?? "long";
    var pkName = pkProp?.Name ?? "Id";

    // 生成指纹与日期
    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
    var metaHash = Math.Abs(Model.FullName.GetHashCode() ^ DateTime.Now.Ticks).ToString("X8");
}
// <auto-generated>
// 此文件由 xCodeGen 自动生成，请勿手动修改。
// 模型: @Model.ClassName (@Model.FullName)
// 生成时间: @timestamp
// 校验哈希: @metaHash
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using FreeSql;
using TKW.Framework.Domain;
using TKW.Framework.Common.Entity;
using @Model.Namespace;

namespace @namespaceName;

/// <summary>
/// @summary
/// </summary>
public partial class @serviceName : DomainServiceBase<DmpUserInfo>
{
    protected readonly IFreeSql _fsql;
    protected IBaseRepository<@className> Repo => _fsql.GetRepository<@className>();

    public @(serviceName)(DomainUser<DmpUserInfo> user, IFreeSql fsql) : base(user)
    {
        _fsql = fsql ?? throw new ArgumentNullException(nameof(fsql));
    }

    // ───────────────────────────────────────────────────────────────
    // 表现层查询接口 (R) - 公开
    // ───────────────────────────────────────────────────────────────

    /// <summary>
    /// 提供给 GraphQL 使用的标准查询入口，支持动态分页、过滤、排序。
    /// </summary>
    public IQueryable<@className> GetGraphQLQueryable()
    {
        var select = QueryForUser();
        OnGraphQLFiltering(ref select);
        return select.AsQueryable();
    }

    /// <summary>
    /// 获取当前用户可访问的基础查询源（强制附加安全过滤）
    /// </summary>
    public ISelect<@className> QueryForUser()
    {
        var q = _fsql.Select<@className>();
        @if (hasIsDeleted) {
            @:q = q.Where(x => !x.IsDeleted);
        }
        OnQueryFiltering(ref q);
        return q;
    }

    /// <summary>
    /// 按 ID 获取（公有方法）
    /// </summary>
    public Task<@className> GetByIdAsync(@pkType id, CancellationToken ct = default)
    {
        return QueryForUser().Where(x => x.@pkName == id).FirstAsync(ct);
    }

    // ───────────────────────────────────────────────────────────────
    // 业务支撑查询 (受保护)
    // ───────────────────────────────────────────────────────────────

    protected Task<@className> GetSingleAsync(Expression<Func<@className, bool>> predicate, CancellationToken ct = default)
    {
        return QueryForUser().Where(predicate).FirstAsync(ct);
    }

    // ───────────────────────────────────────────────────────────────
    // 状态开关方法 (受保护)
    // ───────────────────────────────────────────────────────────────

    @if (hasIsEnabled) {
    @:/// <summary> 设置启用/禁用状态 </summary>
    @:protected async Task<bool> InternalSetEnabledAsync(@pkType id, bool enabled, CancellationToken ct = default)
    @:{
    @:    var affected = await _fsql.Update<@className>().Where(x => x.@pkName == id)
    @:        .Set(x => x.IsEnabled, enabled)
    @:        .ExecuteAffrowsAsync(ct);
    @:    return affected > 0;
    @:}
    }

    @if (hasIsDisabled) {
    @:/// <summary> 设置禁用/启用状态 </summary>
    @:protected async Task<bool> InternalSetDisabledAsync(@pkType id, bool disabled, CancellationToken ct = default)
    @:{
    @:    var affected = await _fsql.Update<@className>().Where(x => x.@pkName == id)
    @:        .Set(x => x.IsDisabled, disabled)
    @:        .ExecuteAffrowsAsync(ct);
    @:    return affected > 0;
    @:}
    }

    // ───────────────────────────────────────────────────────────────
    // 持久化指令 (CUD - 受保护)
    // ───────────────────────────────────────────────────────────────

    protected async Task<@className> InternalCreateAsync(@className entity, CancellationToken ct = default)
    {
        OnBeforeCreate(entity);
        await Repo.InsertAsync(entity, ct);
        OnAfterCreate(entity);
        return entity;
    }

    protected async Task InternalUpdateAsync(@className entity, CancellationToken ct = default)
    {
        OnBeforeUpdate(entity);
        await Repo.UpdateAsync(entity, ct);
        OnAfterUpdate(entity);
    }

    @if (hasIsDeleted) {
    @:/// <summary> 执行逻辑删除 (软删除) </summary>
    @:protected async Task<bool> InternalSoftDeleteAsync(@pkType id, CancellationToken ct = default)
    @:{
    @:    var entity = await Repo.Select.Where(x => x.@pkName == id).FirstAsync(ct);
    @:    if (entity == null) return false;
    @:    OnBeforeDelete(entity);
    @:    entity.IsDeleted = true;
    @:    var affected = await Repo.UpdateAsync(entity, ct);
    @:    OnAfterDelete(entity);
    @:    return affected > 0;
    @:}

    @:/// <summary> 执行物理删除 (硬删除) </summary>
    @:protected async Task<bool> InternalHardDeleteAsync(@pkType id, CancellationToken ct = default)
    @:{
    @:    var entity = await Repo.Select.Where(x => x.@pkName == id).FirstAsync(ct);
    @:    if (entity == null) return false;
    @:    OnBeforeDelete(entity);
    @:    var affected = await Repo.DeleteAsync(entity, ct);
    @:    OnAfterDelete(entity);
    @:    return affected > 0;
    @:}
    } else {
    @:/// <summary> 执行物理删除 </summary>
    @:protected async Task<bool> InternalDeleteAsync(@pkType id, CancellationToken ct = default)
    @:{
    @:    var entity = await Repo.Select.Where(x => x.@pkName == id).FirstAsync(ct);
    @:    if (entity == null) return false;
    @:    OnBeforeDelete(entity);
    @:    var affected = await Repo.DeleteAsync(entity, ct);
    @:    OnAfterDelete(entity);
    @:    return affected > 0;
    @:}
    }

    // ───────────────────────────────────────────────────────────────
    // 生命周期钩子 (Partial Methods)
    // ───────────────────────────────────────────────────────────────

    partial void OnQueryFiltering(ref ISelect<@className> query);
    partial void OnGraphQLFiltering(ref ISelect<@className> query);
    partial void OnBeforeCreate(@className entity);
    partial void OnAfterCreate(@className entity);
    partial void OnBeforeUpdate(@className entity);
    partial void OnAfterUpdate(@className entity);
    partial void OnBeforeDelete(@className entity);
    partial void OnAfterDelete(@className entity);
}